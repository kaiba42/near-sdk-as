"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ast_1 = require("./ast");
const ASTBuilder_1 = require("./ASTBuilder");
const base_1 = require("./base");
function returnsVoid(node) {
    return toString(node.signature.returnType) === "void";
}
function numOfParameters(node) {
    return node.signature.parameters.length;
}
function hasNearDecorator(stmt) {
    return (stmt.text.includes("@nearfile") || isEntry(stmt)) && !stmt.text.includes("@notNearfile");
}
function toString(node) {
    return ASTBuilder_1.ASTBuilder.build(node);
}
function isEntry(source) {
    return source.range.source.sourceKind == ast_1.SourceKind.USER_ENTRY;
}
exports.isEntry = isEntry;
function isClass(type) {
    return type.kind == ast_1.NodeKind.CLASSDECLARATION;
}
function isField(mem) {
    return mem.kind == ast_1.NodeKind.FIELDDECLARATION;
}
function createDecodeStatements(_class) {
    return _class.members
        .filter(isField)
        .map((field) => {
        const name = toString(field.name);
        return (createDecodeStatement(field, `this.${name} = obj.has("${name}") ? `) +
            `: ${field.initializer != null ? toString(field.initializer) : `this.${name}`};`);
    });
}
function createDecodeStatement(field, setterPrefix = "") {
    let T = toString(field.type);
    let name = toString(field.name);
    return `${setterPrefix}decode<${T}, JSON.Obj>(obj, "${name}")`;
}
function createEncodeStatements(_class) {
    return _class.members
        .filter(isField)
        .map((field) => {
        let T = toString(field.type);
        let name = toString(field.name);
        return `encode<${T}, JSONEncoder>(this.${name}, "${name}", encoder);`;
    });
}
// TODO: Extract this into separate module, preferrable pluggable
class JSONBindingsBuilder extends base_1.BaseVisitor {
    constructor() {
        super(...arguments);
        this.sb = [];
        this.exportedClasses = new Map();
        this.wrappedFuncs = new Set();
    }
    static build(parser, source) {
        return new JSONBindingsBuilder().build(source);
    }
    static nearFiles(parser) {
        return parser.program.sources.filter(hasNearDecorator);
    }
    visitClassDeclaration(node) {
        if (!this.exportedClasses.has(toString(node.name))) {
            this.exportedClasses.set(toString(node.name), node);
        }
        super.visitClassDeclaration(node);
    }
    visitFunctionDeclaration(node) {
        if (!isEntry(node) ||
            this.wrappedFuncs.has(toString(node.name)) ||
            !node.is(ast_1.CommonFlags.EXPORT) ||
            (numOfParameters(node) == 0 && returnsVoid(node))) {
            super.visitFunctionDeclaration(node);
            return;
        }
        this.generateWrapperFunction(node);
        // Change function to not be an export
        node.flags = node.flags ^ ast_1.CommonFlags.EXPORT;
        this.wrappedFuncs.add(toString(node.name));
        super.visit(node);
    }
    /*
    Create a wrapper function that will be export in the function's place.
    */
    generateWrapperFunction(func) {
        let signature = func.signature;
        let params = signature.parameters;
        let returnType = signature.returnType;
        let returnTypeName = toString(returnType)
            .split("|")
            .map(name => name.trim())
            .filter(name => name !== "null")
            .join("|");
        let hasNull = toString(returnType).includes("null");
        let name = func.name.text;
        this.sb.push(`function __wrapper_${name}(): void {`);
        if (params.length > 0) {
            this.sb.push(`  const obj = getInput();`);
        }
        if (toString(returnType) !== "void") {
            this.sb.push(`  let result: ${toString(returnType)} = ${name}(`);
        }
        else {
            this.sb.push(`  ${name}(`);
        }
        if (params.length > 0) {
            this.sb[this.sb.length - 1] += params
                .map(param => createDecodeStatement(param))
                .join(", ");
        }
        this.sb[this.sb.length - 1] += ");";
        if (toString(returnType) !== "void") {
            this.sb.push(`  const val = encode<${returnTypeName}>(${hasNull ? `changetype<${returnTypeName}>(result)` : "result"});
  value_return(val.byteLength, val.dataStart);`);
        }
        this.sb.push(`}
export { __wrapper_${name} as ${name} }`);
    }
    typeName(type) {
        if (!isClass(type)) {
            return toString(type);
        }
        type = type;
        let className = toString(type.name);
        if (type.isGeneric) {
            className += "<" + type.typeParameters.map(toString).join(", ") + ">";
        }
        return className;
    }
    build(source) {
        this.sb = [];
        this.visit(source);
        let sourceText = source.statements.map(stmt => {
            let str = toString(stmt);
            if (isClass(stmt)) {
                let _class = stmt;
                str = str.slice(0, str.lastIndexOf("}"));
                let fields = _class.members
                    .filter(isField)
                    .map((field) => field);
                if (fields.some(field => field.type == null)) {
                    throw new Error("All Fields must have explict type declaration.");
                }
                let className = this.typeName(_class);
                str += `
  decode<V = Uint8Array>(buf: V): ${className} {
    let json: JSON.Obj;
    if (buf instanceof Uint8Array) {
      json = JSON.parse(buf);
    } else {
      assert(buf instanceof JSON.Obj, "argument must be Uint8Array or Json Object");
      json = <JSON.Obj> buf;
    }
    return this._decode(json);
  }

  static decode(buf: Uint8Array): ${className} {
    return decode<${className}>(buf);
  }

  private _decode(obj: JSON.Obj): ${className} {
    ${createDecodeStatements(_class).join("\n    ")}
    return this;
  }

  _encode(name: string | null = "", _encoder: JSONEncoder | null = null): JSONEncoder {
    let encoder = _encoder == null ? new JSONEncoder() : _encoder;
    encoder.pushObject(name);
    ${createEncodeStatements(_class).join("\n    ")}
    encoder.popObject();
    return encoder;
  }
  encode(): Uint8Array {
    return this._encode().serialize();
  }

  serialize(): Uint8Array {
    return this.encode();
  }

  toJSON(): string {
    return this._encode().toString();
  }
}`;
            }
            return str;
        });
        return sourceText.concat(this.sb).join("\n");
    }
}
exports.JSONBindingsBuilder = JSONBindingsBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSlNPTkJ1aWxkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvSlNPTkJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwrQkFhZTtBQUNmLDZDQUEwQztBQUMxQyxpQ0FBcUM7QUFFckMsU0FBUyxXQUFXLENBQUMsSUFBeUI7SUFDNUMsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsS0FBSyxNQUFNLENBQUM7QUFDeEQsQ0FBQztBQUVELFNBQVMsZUFBZSxDQUFDLElBQXlCO0lBQ2hELE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDO0FBQzFDLENBQUM7QUFFRCxTQUFTLGdCQUFnQixDQUFDLElBQVk7SUFDcEMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDbkcsQ0FBQztBQUVELFNBQVMsUUFBUSxDQUFDLElBQVU7SUFDMUIsT0FBTyx1QkFBVSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNoQyxDQUFDO0FBRUQsU0FBZ0IsT0FBTyxDQUFDLE1BQXFCO0lBQzNDLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsVUFBVSxJQUFJLGdCQUFVLENBQUMsVUFBVSxDQUFDO0FBQ2pFLENBQUM7QUFGRCwwQkFFQztBQUVELFNBQVMsT0FBTyxDQUFDLElBQVU7SUFDekIsT0FBTyxJQUFJLENBQUMsSUFBSSxJQUFJLGNBQVEsQ0FBQyxnQkFBZ0IsQ0FBQztBQUNoRCxDQUFDO0FBRUQsU0FBUyxPQUFPLENBQUMsR0FBeUI7SUFDeEMsT0FBTyxHQUFHLENBQUMsSUFBSSxJQUFJLGNBQVEsQ0FBQyxnQkFBZ0IsQ0FBQztBQUMvQyxD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SUFBSSxLQUFLLENBQUMsZ0RBQWdELENBQUMsQ0FBQztpQkFDbkU7Z0JBQ0QsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDdEMsR0FBRyxJQUFJO29DQUNxQixTQUFTOzs7Ozs7Ozs7OztvQ0FXVCxTQUFTO29CQUN6QixTQUFTOzs7b0NBR08sU0FBUztNQUN2QyxzQkFBc0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDOzs7Ozs7O01BTzdDLHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7Ozs7Ozs7Ozs7Ozs7OztFQWVqRCxDQUFDO2FBQ0k7WUFDRCxPQUFPLEdBQUcsQ0FBQztRQUNiLENBQUMsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDL0MsQ0FBQztDQUNGO0FBbkpELGtEQW1KQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIE5vZGUsXG4gIEZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gIE5vZGVLaW5kLFxuICBTb3VyY2UsXG4gIFNvdXJjZUtpbmQsXG4gIFR5cGVOb2RlLFxuICBDbGFzc0RlY2xhcmF0aW9uLFxuICBEZWNsYXJhdGlvblN0YXRlbWVudCxcbiAgUGFyc2VyLFxuICBDb21tb25GbGFncyxcbiAgRmllbGREZWNsYXJhdGlvbixcbiAgUGFyYW1ldGVyTm9kZSxcbn0gZnJvbSBcIi4vYXN0XCI7XG5pbXBvcnQgeyBBU1RCdWlsZGVyIH0gZnJvbSBcIi4vQVNUQnVpbGRlclwiO1xuaW1wb3J0IHsgQmFzZVZpc2l0b3IgfSBmcm9tIFwiLi9iYXNlXCI7XG5cbmZ1bmN0aW9uIHJldHVybnNWb2lkKG5vZGU6IEZ1bmN0aW9uRGVjbGFyYXRpb24pOiBib29sZWFuIHtcbiAgcmV0dXJuIHRvU3RyaW5nKG5vZGUuc2lnbmF0dXJlLnJldHVyblR5cGUpID09PSBcInZvaWRcIjtcbn1cblxuZnVuY3Rpb24gbnVtT2ZQYXJhbWV0ZXJzKG5vZGU6IEZ1bmN0aW9uRGVjbGFyYXRpb24pOiBudW1iZXIge1xuICByZXR1cm4gbm9kZS5zaWduYXR1cmUucGFyYW1ldGVycy5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGhhc05lYXJEZWNvcmF0b3Ioc3RtdDogU291cmNlKTogYm9vbGVhbiB7XG4gIHJldHVybiAoc3RtdC50ZXh0LmluY2x1ZGVzKFwiQG5lYXJmaWxlXCIpIHx8IGlzRW50cnkoc3RtdCkpICYmICFzdG10LnRleHQuaW5jbHVkZXMoXCJAbm90TmVhcmZpbGVcIik7XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKG5vZGU6IE5vZGUpOiBzdHJpbmcge1xuICByZXR1cm4gQVNUQnVpbGRlci5idWlsZChub2RlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRW50cnkoc291cmNlOiBTb3VyY2UgfCBOb2RlKTogYm9vbGVhbiB7XG4gIHJldHVybiBzb3VyY2UucmFuZ2Uuc291cmNlLnNvdXJjZUtpbmQgPT0gU291cmNlS2luZC5VU0VSX0VOVFJZO1xufVxuXG5mdW5jdGlvbiBpc0NsYXNzKHR5cGU6IE5vZGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGUua2luZCA9PSBOb2RlS2luZC5DTEFTU0RFQ0xBUkFUSU9OO1xufVxuXG5mdW5jdGlvbiBpc0ZpZWxkKG1lbTogRGVjbGFyYXRpb25TdGF0ZW1lbnQpIHtcbiAgcmV0dXJuIG1lbS5raW5kID09IE5vZGVLaW5kLkZJRUxEREVDTEFSQVRJT047XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlY29kZVN0YXRlbWVudHMoX2NsYXNzOiBDbGFzc0RlY2xhcmF0aW9uKTogc3RyaW5nW10ge1xuICByZXR1cm4gX2NsYXNzLm1lbWJlcnNcbiAgICAuZmlsdGVyKGlzRmllbGQpXG4gICAgLm1hcCgoZmllbGQ6IEZpZWxkRGVjbGFyYXRpb24pOiBzdHJpbmcgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IHRvU3RyaW5nKGZpZWxkLm5hbWUpO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgY3JlYXRlRGVjb2RlU3RhdGVtZW50KGZpZWxkLCBgdGhpcy4ke25hbWV9ID0gb2JqLmhhcyhcIiR7bmFtZX1cIikgPyBgKSArXG4gICAgICAgIGA6ICR7ZmllbGQuaW5pdGlhbGl6ZXIgIT0gbnVsbCA/IHRvU3RyaW5nKGZpZWxkLmluaXRpYWxpemVyKSA6IGB0aGlzLiR7bmFtZX1gfTtgXG4gICAgICApO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWNvZGVTdGF0ZW1lbnQoXG4gIGZpZWxkOiBGaWVsZERlY2xhcmF0aW9uIHwgUGFyYW1ldGVyTm9kZSxcbiAgc2V0dGVyUHJlZml4OiBzdHJpbmcgPSBcIlwiXG4pOiBzdHJpbmcge1xuICBsZXQgVCA9IHRvU3RyaW5nKGZpZWxkLnR5cGUhKTtcbiAgbGV0IG5hbWUgPSB0b1N0cmluZyhmaWVsZC5uYW1lKTtcbiAgcmV0dXJuIGAke3NldHRlclByZWZpeH1kZWNvZGU8JHtUfSwgSlNPTi5PYmo+KG9iaiwgXCIke25hbWV9XCIpYDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW5jb2RlU3RhdGVtZW50cyhfY2xhc3M6IENsYXNzRGVjbGFyYXRpb24pOiBzdHJpbmdbXSB7XG4gIHJldHVybiBfY2xhc3MubWVtYmVyc1xuICAgIC5maWx0ZXIoaXNGaWVsZClcbiAgICAubWFwKChmaWVsZDogRmllbGREZWNsYXJhdGlvbik6IHN0cmluZyA9PiB7XG4gICAgICBsZXQgVCA9IHRvU3RyaW5nKGZpZWxkLnR5cGUhKTtcbiAgICAgIGxldCBuYW1lID0gdG9TdHJpbmcoZmllbGQubmFtZSk7XG4gICAgICByZXR1cm4gYGVuY29kZTwke1R9LCBKU09ORW5jb2Rlcj4odGhpcy4ke25hbWV9LCBcIiR7bmFtZX1cIiwgZW5jb2Rlcik7YDtcbiAgICB9KTtcbn1cblxuLy8gVE9ETzogRXh0cmFjdCB0aGlzIGludG8gc2VwYXJhdGUgbW9kdWxlLCBwcmVmZXJyYWJsZSBwbHVnZ2FibGVcbmV4cG9ydCBjbGFzcyBKU09OQmluZGluZ3NCdWlsZGVyIGV4dGVuZHMgQmFzZVZpc2l0b3Ige1xuICBwcml2YXRlIHNiOiBzdHJpbmdbXSA9IFtdO1xuICBwcml2YXRlIGV4cG9ydGVkQ2xhc3NlczogTWFwPHN0cmluZywgQ2xhc3NEZWNsYXJhdGlvbj4gPSBuZXcgTWFwKCk7XG4gIHdyYXBwZWRGdW5jczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG5cbiAgc3RhdGljIGJ1aWxkKHBhcnNlcjogUGFyc2VyLCBzb3VyY2U6IFNvdXJjZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5ldyBKU09OQmluZGluZ3NCdWlsZGVyKCkuYnVpbGQoc291cmNlKTtcbiAgfVxuXG4gIHN0YXRpYyBuZWFyRmlsZXMocGFyc2VyOiBQYXJzZXIpOiBTb3VyY2VbXSB7XG4gICAgcmV0dXJuIHBhcnNlci5wcm9ncmFtLnNvdXJjZXMuZmlsdGVyKGhhc05lYXJEZWNvcmF0b3IpO1xuICB9XG5cbiAgdmlzaXRDbGFzc0RlY2xhcmF0aW9uKG5vZGU6IENsYXNzRGVjbGFyYXRpb24pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuZXhwb3J0ZWRDbGFzc2VzLmhhcyh0b1N0cmluZyhub2RlLm5hbWUpKSkge1xuICAgICAgdGhpcy5leHBvcnRlZENsYXNzZXMuc2V0KHRvU3RyaW5nKG5vZGUubmFtZSksIG5vZGUpO1xuICAgIH1cbiAgICBzdXBlci52aXNpdENsYXNzRGVjbGFyYXRpb24obm9kZSk7XG4gIH1cblxuICB2aXNpdEZ1bmN0aW9uRGVjbGFyYXRpb24obm9kZTogRnVuY3Rpb25EZWNsYXJhdGlvbik6IHZvaWQge1xuICAgIGlmIChcbiAgICAgICFpc0VudHJ5KG5vZGUpIHx8XG4gICAgICB0aGlzLndyYXBwZWRGdW5jcy5oYXModG9TdHJpbmcobm9kZS5uYW1lKSkgfHxcbiAgICAgICFub2RlLmlzKENvbW1vbkZsYWdzLkVYUE9SVCkgfHxcbiAgICAgIChudW1PZlBhcmFtZXRlcnMobm9kZSkgPT0gMCAmJiByZXR1cm5zVm9pZChub2RlKSlcbiAgICApIHtcbiAgICAgIHN1cGVyLnZpc2l0RnVuY3Rpb25EZWNsYXJhdGlvbihub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5nZW5lcmF0ZVdyYXBwZXJGdW5jdGlvbihub2RlKTtcbiAgICAvLyBDaGFuZ2UgZnVuY3Rpb24gdG8gbm90IGJlIGFuIGV4cG9ydFxuICAgIG5vZGUuZmxhZ3MgPSBub2RlLmZsYWdzIF4gQ29tbW9uRmxhZ3MuRVhQT1JUO1xuICAgIHRoaXMud3JhcHBlZEZ1bmNzLmFkZCh0b1N0cmluZyhub2RlLm5hbWUpKTtcbiAgICBzdXBlci52aXNpdChub2RlKTtcbiAgfVxuXG4gIC8qXG4gIENyZWF0ZSBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4cG9ydCBpbiB0aGUgZnVuY3Rpb24ncyBwbGFjZS5cbiAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZVdyYXBwZXJGdW5jdGlvbihmdW5jOiBGdW5jdGlvbkRlY2xhcmF0aW9uKSB7XG4gICAgbGV0IHNpZ25hdHVyZSA9IGZ1bmMuc2lnbmF0dXJlO1xuICAgIGxldCBwYXJhbXMgPSBzaWduYXR1cmUucGFyYW1ldGVycztcbiAgICBsZXQgcmV0dXJuVHlwZSA9IHNpZ25hdHVyZS5yZXR1cm5UeXBlO1xuICAgIGxldCByZXR1cm5UeXBlTmFtZSA9IHRvU3RyaW5nKHJldHVyblR5cGUpXG4gICAgICAuc3BsaXQoXCJ8XCIpXG4gICAgICAubWFwKG5hbWUgPT4gbmFtZS50cmltKCkpXG4gICAgICAuZmlsdGVyKG5hbWUgPT4gbmFtZSAhPT0gXCJudWxsXCIpXG4gICAgICAuam9pbihcInxcIik7XG4gICAgbGV0IGhhc051bGwgPSB0b1N0cmluZyhyZXR1cm5UeXBlKS5pbmNsdWRlcyhcIm51bGxcIik7XG4gICAgbGV0IG5hbWUgPSBmdW5jLm5hbWUudGV4dDtcblxuICAgIHRoaXMuc2IucHVzaChgZnVuY3Rpb24gX193cmFwcGVyXyR7bmFtZX0oKTogdm9pZCB7YCk7XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNiLnB1c2goYCAgY29uc3Qgb2JqID0gZ2V0SW5wdXQoKTtgKTtcbiAgICB9XG4gICAgaWYgKHRvU3RyaW5nKHJldHVyblR5cGUpICE9PSBcInZvaWRcIikge1xuICAgICAgdGhpcy5zYi5wdXNoKGAgIGxldCByZXN1bHQ6ICR7dG9TdHJpbmcocmV0dXJuVHlwZSl9ID0gJHtuYW1lfShgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zYi5wdXNoKGAgICR7bmFtZX0oYCk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zYlt0aGlzLnNiLmxlbmd0aCAtIDFdICs9IHBhcmFtc1xuICAgICAgICAubWFwKHBhcmFtID0+IGNyZWF0ZURlY29kZVN0YXRlbWVudChwYXJhbSkpXG4gICAgICAgIC5qb2luKFwiLCBcIik7XG4gICAgfVxuICAgIHRoaXMuc2JbdGhpcy5zYi5sZW5ndGggLSAxXSArPSBcIik7XCI7XG4gICAgaWYgKHRvU3RyaW5nKHJldHVyblR5cGUpICE9PSBcInZvaWRcIikge1xuICAgICAgdGhpcy5zYi5wdXNoKGAgIGNvbnN0IHZhbCA9IGVuY29kZTwke3JldHVyblR5cGVOYW1lfT4oJHtoYXNOdWxsID8gYGNoYW5nZXR5cGU8JHtyZXR1cm5UeXBlTmFtZX0+KHJlc3VsdClgIDogXCJyZXN1bHRcIn0pO1xuICB2YWx1ZV9yZXR1cm4odmFsLmJ5dGVMZW5ndGgsIHZhbC5kYXRhU3RhcnQpO2ApO1xuICAgIH1cbiAgICB0aGlzLnNiLnB1c2goYH1cbmV4cG9ydCB7IF9fd3JhcHBlcl8ke25hbWV9IGFzICR7bmFtZX0gfWApO1xuICB9XG5cbiAgcHJpdmF0ZSB0eXBlTmFtZSh0eXBlOiBUeXBlTm9kZSB8IENsYXNzRGVjbGFyYXRpb24pOiBzdHJpbmcge1xuICAgIGlmICghaXNDbGFzcyh0eXBlKSkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHR5cGUpO1xuICAgIH1cbiAgICB0eXBlID0gPENsYXNzRGVjbGFyYXRpb24+dHlwZTtcbiAgICBsZXQgY2xhc3NOYW1lID0gdG9TdHJpbmcodHlwZS5uYW1lKTtcbiAgICBpZiAodHlwZS5pc0dlbmVyaWMpIHtcbiAgICAgIGNsYXNzTmFtZSArPSBcIjxcIiArIHR5cGUudHlwZVBhcmFtZXRlcnMhLm1hcCh0b1N0cmluZykuam9pbihcIiwgXCIpICsgXCI+XCI7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH1cblxuICBidWlsZChzb3VyY2U6IFNvdXJjZSk6IHN0cmluZyB7XG4gICAgdGhpcy5zYiA9IFtdO1xuICAgIHRoaXMudmlzaXQoc291cmNlKTtcbiAgICBsZXQgc291cmNlVGV4dCA9IHNvdXJjZS5zdGF0ZW1lbnRzLm1hcChzdG10ID0+IHtcbiAgICAgIGxldCBzdHIgPSB0b1N0cmluZyhzdG10KTtcbiAgICAgIGlmIChpc0NsYXNzKHN0bXQpKSB7XG4gICAgICAgIGxldCBfY2xhc3MgPSA8Q2xhc3NEZWNsYXJhdGlvbj5zdG10O1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgc3RyLmxhc3RJbmRleE9mKFwifVwiKSk7XG4gICAgICAgIGxldCBmaWVsZHMgPSBfY2xhc3MubWVtYmVyc1xuICAgICAgICAgIC5maWx0ZXIoaXNGaWVsZClcbiAgICAgICAgICAubWFwKChmaWVsZDogRmllbGREZWNsYXJhdGlvbikgPT4gZmllbGQpO1xuICAgICAgICBpZiAoZmllbGRzLnNvbWUoZmllbGQgPT4gZmllbGQudHlwZSA9PSBudWxsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFsbCBGaWVsZHMgbXVzdCBoYXZlIGV4cGxpY3QgdHlwZSBkZWNsYXJhdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9IHRoaXMudHlwZU5hbWUoX2NsYXNzKTtcbiAgICAgICAgc3RyICs9IGBcbiAgZGVjb2RlPFYgPSBVaW50OEFycmF5PihidWY6IFYpOiAke2NsYXNzTmFtZX0ge1xuICAgIGxldCBqc29uOiBKU09OLk9iajtcbiAgICBpZiAoYnVmIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAganNvbiA9IEpTT04ucGFyc2UoYnVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KGJ1ZiBpbnN0YW5jZW9mIEpTT04uT2JqLCBcImFyZ3VtZW50IG11c3QgYmUgVWludDhBcnJheSBvciBKc29uIE9iamVjdFwiKTtcbiAgICAgIGpzb24gPSA8SlNPTi5PYmo+IGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RlY29kZShqc29uKTtcbiAgfVxuXG4gIHN0YXRpYyBkZWNvZGUoYnVmOiBVaW50OEFycmF5KTogJHtjbGFzc05hbWV9IHtcbiAgICByZXR1cm4gZGVjb2RlPCR7Y2xhc3NOYW1lfT4oYnVmKTtcbiAgfVxuXG4gIHByaXZhdGUgX2RlY29kZShvYmo6IEpTT04uT2JqKTogJHtjbGFzc05hbWV9IHtcbiAgICAke2NyZWF0ZURlY29kZVN0YXRlbWVudHMoX2NsYXNzKS5qb2luKFwiXFxuICAgIFwiKX1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIF9lbmNvZGUobmFtZTogc3RyaW5nIHwgbnVsbCA9IFwiXCIsIF9lbmNvZGVyOiBKU09ORW5jb2RlciB8IG51bGwgPSBudWxsKTogSlNPTkVuY29kZXIge1xuICAgIGxldCBlbmNvZGVyID0gX2VuY29kZXIgPT0gbnVsbCA/IG5ldyBKU09ORW5jb2RlcigpIDogX2VuY29kZXI7XG4gICAgZW5jb2Rlci5wdXNoT2JqZWN0KG5hbWUpO1xuICAgICR7Y3JlYXRlRW5jb2RlU3RhdGVtZW50cyhfY2xhc3MpLmpvaW4oXCJcXG4gICAgXCIpfVxuICAgIGVuY29kZXIucG9wT2JqZWN0KCk7XG4gICAgcmV0dXJuIGVuY29kZXI7XG4gIH1cbiAgZW5jb2RlKCk6IFVpbnQ4QXJyYXkge1xuICAgIHJldHVybiB0aGlzLl9lbmNvZGUoKS5zZXJpYWxpemUoKTtcbiAgfVxuXG4gIHNlcmlhbGl6ZSgpOiBVaW50OEFycmF5IHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGUoKTtcbiAgfVxuXG4gIHRvSlNPTigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9lbmNvZGUoKS50b1N0cmluZygpO1xuICB9XG59YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNvdXJjZVRleHQuY29uY2F0KHRoaXMuc2IpLmpvaW4oXCJcXG5cIik7XG4gIH1cbn1cbiJdfQ==